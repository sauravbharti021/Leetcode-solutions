#define rep(i,n) for(int i=0;i<n;i++)
class Solution {
public:
    vector<vector<int>> dir{{0,1},{1,0},{-1,0},{0,-1}};
    struct Cell{
        int height, x, y;
        bool operator<(const Cell& other) const {
            return height > other.height; // Min-heap
        } 
    };
    int trapRainWater(vector<vector<int>>& heightMap) {
        int n = heightMap.size(), m= heightMap[0].size();
        vector<vector<int>> dis(n, vector<int>(m, 1e9));
        priority_queue<Cell> p;
        rep(i,n){
            dis[i][0] = heightMap[i][0];
            p.push({heightMap[i][0], i, 0});
            dis[i][m-1] = heightMap[i][m-1];
            p.push({heightMap[i][m-1], i, m-1});
        }
        rep(i,m){
            dis[0][i] = heightMap[0][i];
            p.push({heightMap[0][i], 0, i});
            dis[n-1][i] = heightMap[n-1][i];
            p.push({heightMap[n-1][i], n-1, i});
        }

        while(!p.empty()){
            Cell f = p.top();
            p.pop();
            if(f.height!=dis[f.x][f.y]) continue;
            rep(i,4){
                int u= f.x+ dir[i][0], v = f.y + dir[i][1];
                if(u>=0 && v>=0 && u<n && v<m){
                    int maxHeight = max(f.height, heightMap[u][v]);
                    if(maxHeight < dis[u][v]){
                        dis[u][v] = maxHeight;
                        p.push({maxHeight, u, v});
                    }
                } 
            }
        }

        int ans = 0;
        rep(i,n){
            rep(j,m){
                ans+=(dis[i][j]-heightMap[i][j]);
            }
        }
        return ans;
    }
};
